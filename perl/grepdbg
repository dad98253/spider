#!/usr/bin/perl
#
# Program to do a grep with dates and times on the debug
# files
#
# grepdbg [nn] [-mm] <regular expression>
#

# nn - is the day you what to look at: 1 is yesterday, 0 is today
# and is optional if there is only one argument
#
# -mmm - print the mmm lines before the match. So -10 will print
# ten lines including the line matching the regular expression. 
#
# <regexp> is the regular expression you are searching for, 
# a caseless search is done
#
#

require 5.004;

# search local then perl directories
BEGIN {
	# root of directory tree for this system
	$root = "/spider"; 
	$root = $ENV{'DXSPIDER_ROOT'} if $ENV{'DXSPIDER_ROOT'};
	
	unshift @INC, "$root/perl";	# this IS the right way round!
	unshift @INC, "$root/local";
	sub main::mkver {}
}

use DXVars;
use DXUtil;
use DXLog;
use Julian;

use strict;

use vars qw(@list $fp $today $string);

$fp = DXLog::new('debug', 'dat', 'd');
$today = $fp->unixtoj(time()); 
my $nolines = 1;
my @prev;

for my $arg (@ARGV) {
	if ($arg =~ /^-/) {
		$arg =~ s/^-//o;
		push @list, $arg;
	} elsif ($arg =~ /^\d+$/) {
		$nolines = $arg;
	} else {
		$string = $arg;
		last;
	}
}
die "usage: grepdbg [nn] [[-nnn] ..] <regexp>\n" unless  $string;

push @list, "0" unless @list;
for my $entry (@list) {
	my $now = $today->sub($entry); 
	my $fh = $fp->open($now); 
	my $line;
	if ($fh) {
		while (<$fh>) {
			my $line = $_;
			chomp $line;
			push @prev, $line;
			shift @prev while @prev > $nolines;
			if ($line =~ m{$string}io) {
				for (@prev) {
					s/([\x00-\x1f\x7f-\xff])/sprintf("\\x%02X", ord($1))/eg; 
					my ($t, $l) =  split /\^/, $_, 2;
					print atime($t), ' ', $l, "\n"; 
				}
				@prev = ();
			}
		}
		$fp->close();
	}
}
exit(0);
