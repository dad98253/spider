<!doctype linuxdoc system>

<article>

<!-- Title information -->

<title>The DXSpider Installation and Administration Manual 
<author>Ian Maude, G0VGS, (ianmaude@btinternet.com)
<date>Version 1.24 July 2000
<abstract>
A reference for SysOps of the DXSpider DXCluster program.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<sect>Installation (Original version by Iain Phillips, G0RDI)

<P>
Last modified: 25 July 2000 by Ian Maude, G0VGS

<sect1>Introduction

<P>
This section describes the installation of DX Spider v1.35 on a <htmlurl url="http://www.redhat.com" name="RedHat"> Linux Distribution.  I do not intend to try and cover the installation of Linux or the setup of the AX25 utilities.  If you need help on this then read Iains original HOWTO on the <htmlurl url="http://www.dxcluster.org" name="DXSpider"> website.

<P>
I am assuming a general knowledge of Linux and its commands.  You should know how to use <em>tar</em> and how to edit files using your favourite editor.

<P>
The crucial ingredient for all of this is <htmlurl url="http://www.perl.org" name="Perl 5.004">.Now I know Perl 5.005 is out and this will almost certainly work with it, but <htmlurl url="http://www.redhat.com" name="RedHat 5.1"> comes with 5.004. <em>Be Warned</em>, earlier versions of <htmlurl url="http://www.redhat.com" name="RedHat"> <bf>do not</bf> come with 5.004 as standard, you need to <htmlurl url="ftp://upgrade.redhat.com" name="upgrade">

<P>In addition to the standard Red Hat distribution you will require the following <htmlurl url="http://www.cpan.org/CPAN.html" name="CPAN"> modules: -

<P>
<itemize>

<item>		MD5-1.7.tar.gz
<item>		Data-Dumper-2.10.tar.gz
<item>		FreezeThaw-0.3.tar.gz
<item>		MLDBM-2.00.tar.gz
<item>		TimeDate-1.8.tar.gz
<item>		IO-1.20.tar.gz
<item>		Net-Telnet-3.02.tar.gz
<item>		Curses-1.05.tar.gz

</itemize>

<P>

<em>Do</em> get the latest versions of these packages and install them but use the above list as the earliest versions usable.

<sect1>Preparation

<P>
I will assume that you have already downloaded the latest tarball of the DXSpider software and are ready to install it. I am assuming version 1.35 for this section but of course you would use the latest version.

<P>
Login as root and create a user to run the cluster under.  <bf><it>UNDER NO CIRCUMSTANCES USE ROOT AS THIS USER!</it></bf>.  I am going to use the name <em>sysop</em>.  You can call it anything you wish.  Depending on your security requirements you may wish to use an existing user, however this is your own choice.

<P>
<tscreen><verb>
# adduser -m sysop
</verb></tscreen>

<P>
Now set a password for the user ...

<tscreen><verb>
# passwd sysop
# New UNIX password:
# Retype new UNIX password:
passwd: all authentication tokens updated successfully
</verb></tscreen>

<sect1>Installing the software

<P>
Now to unpack the DX Spider distribution, set symbolic links and group permissions.  Copy the tarball to /home/sysop and do the following.

<tscreen><verb>
# cd ~sysop
# tar xvfz spider-1.35.tar.gz
# ln -s ~sysop/spider /spider
# groupadd -g 251 spider       (or another number)
</verb></tscreen>

If you do not have the command <em>groupadd</em> available to you simply add a line in /etc/group by hand.

<tscreen><verb>
# vi /etc/group                (or your favorite editor)
</verb></tscreen>

You also need to add some others to the group, including your own callsign (this will be used as an alias) and root.  The finished line in /etc/group should look something like this

<tt>
spider:x:251:sysop,g0vgs,root
</tt>

<P>
The next step is to set the permissions on the Spider directory tree and files ....

<tscreen><verb>
# chown -R sysop.spider spider
# find . -type d -exec chmod 2775 {} \;
# find . -type f -exec chmod 775 {} \;
</verb></tscreen>

<P>
This last step allows various users of the group <em>spider</em> to have write access to all the directories.  This is not really needed just yet but will be useful when web interfaces start to appear.

<P>
Finally, you need to fix the permissions on the ax25_call and netrom_call programs.  Check where they are with the <em>locate</em> command and alter the permissions with the <em>chmod</em> command like this ..

<tscreen><verb>
# chown root ax25_call netrom_call
# chmod 4775 ax25_call netrom_call
</verb></tscreen>

<sect1>Setting callsigns etc

<P>
Now login to your machine as the user you created earlier.  In my case that user is called <em>sysop</em>.  Once logged in, issue the following commands ....

<tscreen><verb>
$ cd /spider
$ mkdir local
$ mkdir local_cmd
$ cp perl/DXVars.pm.issue local/DXVars.pm
$ cd local
$ vi DXVars.pm (or your favourite editor)
</verb></tscreen>

<P>
Using the distributed DXVars.pm as a a template, set your cluster callsign, sysop callsign and other user info to suit your own environment. Note that this a perl file which will be parsed and executed as part of the cluster. If you get it wrong then perl will complain when you start the cluster process.  It is important only to alter the text of any section.  Some of the lines look a little odd.  Take this line for example ....

<tt>
$myemail = "ianmaude\@btinternet.com";
</tt>

<P>
There appears to be an extra slash in there.  However this has to be there for the file to work so leave it in.
		
<P><bf>PLEASE USE CAPITAL LETTERS FOR CALLSIGNS</bf>
		
<P>
DON'T alter the DXVars.pm (or any other file) in /spider/perl, they are overwritten with every release. Any files or commands you place in /spider/local or /spider/local_cmd will automagically be used in preference to the ones in /spider/perl EVEN while the cluster is running!

<P>
Save the new file and change directory to ../perl ....

<tscreen><verb>
$ cd ../perl
</verb></tscreen>

<P>
Now type the following command which creates the basic user file with you as the sysop.

<tscreen><verb>
$ create_sysop.pl
</verb></tscreen>

<sect1>Starting up for the first time

<P>
We can now bring spider up for the first time and see if all is well or not!  It should look something like this ...

<tscreen><verb>
$ cluster.pl
DXSpider DX Cluster Version 1.35
Copyright (c) 1998 Dirk Koopman G1TLH
loading prefixes ...
loading band data ...
loading user file system ...
starting listener ...
reading existing message headers
reading cron jobs
orft we jolly well go ...
</verb></tscreen>

<P>
If all is well then login on another term or console as <em>sysop</em> and cd to /spider/perl.  Now issue the following command ...

<tscreen><verb>
$ client.pl
</verb></tscreen>

<P>
This should log you into the cluster as the sysop under the alias callsign we set earlier.  In this case the callsign is G0VGS.  The cluster callsign is set in the DXVars.pm file in /spider/local.  In this case we will assume that this was set as GB7MBC.  You should therefore see this when you login ....

<tscreen><verb>
G0VGS de GB7MBC 19-Nov-1999 2150Z >
</verb></tscreen>

If you do, congratulations!  If not, look over the instructions again, you have probably missed something out.  You can shut spider down again with the command ....

<tscreen><verb>
shutdown
</verb></tscreen>

<P>
and both the cluster and the client should return to Linux prompts.

<sect>The Client program

<P>
In earlier versions of Spider, all the processes were Perl scripts.  This was fine but with a lot of users your computer memory would soon be used up.  To combat this a new client was written in "C".  This client only works for <em>incoming</em> connects at the moment.  Before you can use it though it has to be "made".  CD to /spider/src and type <em>make</em>.  You should see the output on your screen and hopefully now have a small C program called <em>client</em>.  Leave it in this directory.

<sect>Configuration

<sect1>Allowing ax25 connects from users

<P>
As stated previously, the aim of this document is not to tell you how to configure Linux or the ax25 utilities.  However, you do need to add a line in your ax25d.conf to allow connections to DXSpider for your users.  For each interface that you wish to allow connections on, use the following format ...

<tscreen><verb>
default  * * * * * *  - sysop /spider/src/client client %u ax25
</verb></tscreen>

<sect1>Allowing telnet connects from users

<P>
Allowing telnet connections is quite simple.  Firstly you need to add a line in /etc/services to allow connections to a port number, like this ....

<tscreen><verb>
spdlogin   8000/tcp     # spider anonymous login port
</verb></tscreen>

Then add a line in /etc/inetd.conf like this ....

<tscreen><verb>
spdlogin stream tcp nowait root /usr/sbin/tcpd /spider/src/client login telnet
</verb></tscreen>

<P>
This needs to be added above the standard services such as ftp, telnet etc.  Once this is done, you need to restart inetd like this ....

<tscreen><verb>
killall -HUP inetd
</verb></tscreen>


<P>Now login as <em>sysop</em> and cd spider/perl. You can test that spider is accepting telnet logins by issuing the following command ....

<tscreen><verb>
client.pl login telnet
</verb></tscreen>

You should get a login prompt and on issuing a callsign, you will be given access to the cluster.  Note, you will not get a password login.  There seems no good reason for a password prompt to be given so it is not asked for.

<P>
Assuming all is well, then try a telnet from your linux console ....

<tscreen><verb>
telnet localhost 8000
</verb></tscreen>

<P>
You should now get the login prompt and be able to login as before.

<sect1>Setting up node connects

<P>
In order to allow cluster node connections, spider needs to know that the connecting callsign is a cluster node.  This is the case whether the connect is incoming or outgoing.
In spider this is a simple task and can be done in runtime.

<P>
Start up the cluster as you did before and login as the sysop with client.pl.
The cluster node I am wanting to make a connection to is GB7BAA but you would obviously use whatever callsign you required.
At the prompt type ...

<tscreen><verb>
set/node gb7baa
</verb></tscreen>

<P>
The case does not matter as long as you have a version of DXSpider later than 1.33.  Earlier versions required the callsign to be in upper case.

<P>
That is now set, it is as simple as that.  To prove it, login on yet another console as sysop and issue the command ...

<tscreen><verb>
client.pl gb7baa (using the callsign you set as a node)
</verb></tscreen>

<P>
You should get an initialisation string from DXSpider like this ...

<tscreen><verb>
client.pl gb7baa
PC38^GB7MBC^~
</verb></tscreen>

If the callsign you just set up as a cluster node is for an incoming connect, this is all that needs to be done.  If the connection is to be outgoing then a connection script needs to be written.

<sect2>Connection scripts

<P>
Because DXSpider operates under Linux, connections can be made using just about any protocol;  AX25, NETRom, tcp/ip, ROSE etc are all possible examples.  Connect scripts live in the /spider/connect directory and are simple ascii files.  Writing a script for connections is therefore relatively simple.  

<P>
The connect scripts consist of lines which start with the following keywords or symbols:-


<verb>
	
#		All lines starting with a # are ignored, as are completely blank lines.

timeout		timeout followed by a number is the number of seconds to wait for a 
		command to complete. If there is no timeout specified in the script 
		then the default is 60 seconds.

abort		abort is a regular expression containing one or more strings to look 
		for to abort a connection. This is a perl regular expression and is 
		executed ignoring case.

connect		connect followed by ax25 or telnet and some type dependent 
		information. In the case of a telnet connection, there can be up to 
		two parameters.
		The first is the ip address or hostname of the computer you wish to 
		connect to and the second is the port number you want to use (this 
		can be left out if it is a normal telnet session).
		In the case of an ax25 session then this would normally be a call to
		ax25_call or netrom_call as in the example above. It is your
		responsibility to get your node and other ax25 parameters to work 
		before going down this route!

'		' is the delimiting character for a word or phrase of an expect/send 
		line in a chat type script. The words/phrases normally come in pairs, 
		either can be empty. Each line reads input from the connection until 
		it sees the string (or perl regular expression) contained in the
		left hand string. If the left hand string is empty then it doesn't 
		read or wait for anything. The comparison is done ignoring case.
		When the left hand string has found what it is looking for (if it is) 
		then the right hand string is sent to the connection.
		This process is repeated for every line of chat script. 

client		client starts the connection, put the arguments you would want here 
		if you were starting the client program manually. You only need this 
		if the script has a different name to the callsign you are trying to 
		connect to (i.e. you have a script called other which actually 
		connects to GB7DJK-1 [instead of a script called gb7djk-1]).
</verb>


There are many possible ways to configure the script but here are two examples, one for a NETRom/AX25 connect and one for tcp/ip.  

<tscreen><verb>
	timeout 60
	abort (Busy|Sorry|Fail)
	# don't forget to chmod 4775 netrom_call!
	connect ax25 /usr/sbin/netrom_call bbs gb7djk g1tlh
	'Connect' ''
	'Connect' 'c np7'
	'Connect' 'c gb7dxm'
	# you can leave this out if you call the script 'gb7dxm'
	client gb7dxm ax25
</verb></tscreen>

<P>

<tscreen><verb>
	timeout 15
	connect telnet dirkl.tobit.co.uk
	'login' 'gb7djk'
	'word' 'gb7djk'
	# tell GB7DJK-1 that it is connected to GB7DJK
	# you can leave this out if you call this script 'gb7djk'
	client gb7djk telnet
</verb></tscreen>

<P>
Both these examples assume that everything is set up properly at the other end.  You will find other examples in the /spider/examples directory.

<sect2>Starting the connection

<P>
You start the connection, from within a sysop enabled cluster login, by typing in the word <em>connect</em> followed by a script name like this ....

<tscreen><verb>
G0VGS de GB7MBC 13-Dec-1998 2041Z >connect gb7djk-1
connection to GB7DJK-1 started
G0VGS de GB7MBC 13-Dec-1998 2043Z >
</verb></tscreen>

This will start a connection using the script called <em>gb7djk-1</em>.  You can follow the connection by watching the term or console from where you started <em>cluster.pl</em>.  You should see something like this ...

<tscreen><verb>
<- D G1TLH connect gb7djk-1
-> D G1TLH connection to GB7DJK-1 started
-> D G1TLH G1TLH de GB7DJK 13-Dec-1998 2046Z >
timeout set to 15
CONNECT sort: telnet command: dirkl.tobit.co.uk
CHAT "login" -> "gb7djk"
received "
Red Hat Linux release 5.1 (Manhattan)
Kernel 2.0.35 on an i586
"
received "login: "
sent "gb7djk"
CHAT "word" -> "gb7djk"
received "gb7djk"
received "Password: "
sent "gb7djk"
Connected to GB7DJK-1, starting normal protocol
<- O GB7DJK-1 telnet
-> B GB7DJK-1 0
GB7DJK-1 channel func  state 0 -> init
<- D GB7DJK-1 
<- D GB7DJK-1 Last login: Sun Dec 13 17:59:56 from dirk1
<- D GB7DJK-1 PC38^GB7DJK-1^~
<- D GB7DJK-1 PC18^ 1 nodes, 0 local / 1 total users  Max users 0  Uptime 0 00:00^5447^~
    etc

</verb></tscreen>

<P>
With later versions of Spider there is a set/login command for users.  This tells them when a user or node logs in or out.  If you do not add a line to your scripts after the final line (or before the client line which should always be last if needed) then the login/logout information will be sent to users <it>before</it> the login actually completes.  This means if a node is unreachable, it will continue sending logins and logouts to users even though it is not actually connecting.  To avoid this use the following line ...

<tscreen><verb>
'connect' ''
</verb></tscreen>

<P>
In a script, this might look like ...

<tscreen><verb>
timeout 35 
abort (Busy|Sorry|Fail)
connect telnet mary 3000
'ogin:' 'gb7mbc'
'>' 'telnet 44.131.93.96 7305'
'connect' ''
</verb></tscreen>

<sect1>Automating things

<P>
Ok, you should now have DXSpider running nicely and allowing connects by cluster nodes or users.  However, it has to be shutdown and restarted manually and if connection scripts fail they have to be started again manually too, not much use if you are not at the console!
So, in this section we will automate both.  Firstly starting the cluster.

<sect2>Autostarting the cluster

<P>
This is not only a way to start the cluster automatically, it also works as a watchdog, checking the sanity of DXSpider and respawning it should it crash for any reason.
Before doing the following, shutdown the cluster as you did earlier.

<P>
Login as root and bring up the /etc/inittab file in your favourite editor.  Add the following lines to the file near the end ...

<tscreen><verb>
##Start DXSpider on bootup and respawn it should it crash
DX:3:respawn:/bin/su -c "/usr/bin/perl -w /spider/perl/cluster.pl" sysop >/dev/tty7
</verb></tscreen>

<P>
This will automatically start DXSpider on tty7 (ALT-F7) on bootup and restart it should it crash for any reason.

<P>
As root type the command <em>telinit q</em>.  DXSpider should start up immediately.  You will see the output on tty7 and if you login as <em>sysop</em> you should find everything running nicely.

<P>
So far so good, now to automate script connections...

<sect2>The crontab file

<P>
Login as <em>sysop</em> and create a file in /spider/local_cmd called crontab.  Edit it with your favourite editor and add a line like this (I have included a comment)

<tscreen><verb>
# check every 10 minutes to see if gb7xxx is connected and if not
# start a connect job going

0,10,20,30,40,50 * * * * start_connect('gb7xxx') if !connected('gb7xxx')
</verb></tscreen>

<P>
The callsign involved will be the callsign of the cluster node you are going to connect to.  This will now check every 10 minutes to see if gb7xxx is connected, if it is then nothing will be done.  If it is not, then a connect attempt will be started.

<P>
There are probably lots of other things you could use this crontab file for.  If you want to know more about it, look at the <htmlurl url="http://www.dxcluster.org/cron.html" name="DXSpider"> website at the cron page where it is explained more fully.

<sect>Hop control

<P>
Starting with version 1.13 there is simple hop control available on a per
node basis. Also it is possible to isolate a network completely so that you 
get all the benefits of being on that network, but can't pass on information
from it to any other networks you may be connected to (or vice versa).

<sect1>Basic hop control

<P>
In /spider/data you will find a file called hop_table.pl.  This is the file that controls your hop count settings.  It has a set of default hops on the various PC frames and also a set for each node you want to alter the hops for.  You may be happy with the default settings of course, but this powerful tool can help to protect and improve the network.  The file will look something like this ...

<tscreen><verb>
# 
# hop table construction
# 

package DXProt;

# default hopcount to use
$def_hopcount = 5;

# some variable hop counts based on message type
%hopcount = 

 11 => 10,
 16 => 10,
 17 => 10,
 19 => 10,
 21 => 10,
);


# the per node hop control thingy


%nodehops = 

 GB7ADX => {            11 => 8,
                        12 => 8,
                        16 => 8,
                        17 => 8,
                        19 => 8,
                        21 => 8,
                   },

 GB7UDX => {            11 => 8,
                        12 => 8,
                        16 => 8,
                        17 => 8,
                        19 => 8,
                        21 => 8,
                   },
 GB7BAA => {
                        11 => 5,
                        12 => 8,
                        16 => 8,
                        17 => 8,
                        19 => 8,
                        21 => 8,
                   },
};
</verb></tscreen>

<P>
Each set of hops is contained within a pair of curly braces and contains a series of PC frame types.  PC11 for example is a DX spot. The figures here are not exhaustive but should give you a good idea of how the file works.

<P>
You can alter this file at any time, including whilst the cluster is running.  If you alter the file during runtime, the command <em>load/hops</em> will bring your changes into effect.

<sect1>Isolating networks

<P>
It is possible to isolate networks from each other on a "gateway" node using the
 <em>set/isolate &lt;node_call&gt;</em> command.
	
<P>
The effect of this is to partition an isolated network completely from another 
nodes connected to your node. Your node will appear on and otherwise behave 
normally on every network to which you are connected, but data from an isolated 
network will not cross onto any other network or vice versa. However all the 
spot, announce and WWV traffic and personal messages will still be handled 
locally (because you are a real node on all connected networks), that is locally
connected users will appear on all networks and will be able to access and 
receive information from all networks transparently.  All routed messages will 
be sent as normal, so if a user on one network knows that you are a gateway for 
another network, he can still still send a talk/announce etc message via your 
node and it will be routed across.

<P>
The only limitation currently is that non-private messages cannot be passed down 
isolated links regardless of whether they are generated locally. This will change 
when the bulletin routing facility is added.

<P>
If you use isolate on a node connection you will continue to receive all information from the isolated partner, however you will not pass any information back to the isolated node.  There are times when you would like to forward only spots across a link (maybe during a contest for example).  To do this, isolate the node in the normal way and put in a filter in the /spider/filter/spots directory to override the isolate.  This filter can be very simple and consists of just one line ....

<tscreen><verb>
$in = [
	[ 1, 0, 'd', 0, 3]	# The last figure (3) is the hop count
];
</verb></tscreen>

<P>
There is a lot more on filtering in the next section.

<sect>Filtering

<P>
Filters can be set for spots, announcements and WWV.  You will find the directories for these under /spider/filter.  You will find some examples in the directories with the suffix <em>.issue</em>.  There are two types of filter, one for incoming information and one for outgoing information. Outgoing filters are in the form <em>CALLSIGN.pl</em> and incoming filters are in the form <em>in_CALLSIGN.pl</em>.  Filters can be set for both nodes and users.

<P>
All filters work in basically the same way.  There are several elements delimited by commas.
There can be many lines in the filter and they are read from the top by the program.
When writing a filter you need to think carefully about just what you want to achieve.  You
are either going to write a filter to <em>accept</em> or to <em>reject</em>.
Think of a filter as having 2 main elements.  For a reject filter, you would have a line
or multiple lines rejecting the things you do not wish to receive and then a default
line accepting everything else that is not included in the filter.  Likewise, for an
accept filter, you would have a line or multiple lines accepting the things you wish
to receive and a default line rejecting everthing else.

<P>
In the example below, a user requires a filter that would only return SSB spots
posted in Europe on the HF bands.  This is achieved by first rejecting the CW section 
of each HF band and rejecting all of VHF, UHF etc based on frequency.
Secondly, a filter rule is set based on CQ zones to only accept spots posted in
Europe.  Lastly, a default filter rule is set to reject anything outside the filter.

<tscreen><verb>
$in = [
	[ 0, 0, 'r', # reject all CW spots
		[
		1800.0, 1850.0,
		3500.0, 3600.0,
		7000.0, 7040.0,
		14000.0, 14100.0,
		18068.0, 18110.0,
		21000.0, 21150.0,
		24890.0, 24930.0,
		28000.0, 28180.0,
		30000.0, 49000000000.0,
		] ,1 ],
	[ 1, 11, 'n', [ 14, 15, 16, 20, 33, ], 15 ], #accept EU
	[ 0, 0, 'd', 0, 1 ], # 1 = want, 'd' = everything else
];
</verb></tscreen>

<P>
The actual elements of each filter are described more fully in the following sections.

<sect1>Spots

<P>
The elements of the Spot filter are ....

<tscreen><verb>
[action, field_no, sort, possible_values, hops]
</verb></tscreen>

<P>
There are 3 elements here to look at.  Firstly, the action element.  This is very simple and only 2 possible states exist, accept (1) or drop (0).

<P>
The second element is the field_no.  There are 13 possiblities to choose from here ....

<tscreen><verb>
      0 = frequency
      1 = call
      2 = date in unix format
      3 = comment
      4 = spotter
      5 = spotted dxcc country
      6 = spotter's dxcc country
      7 = origin
      8 = spotted itu
      9 = spotted cq
      10 = spotter's itu
      11 = spotter's cq
      12 = callsign of the channel on which the spot has appeared
</verb></tscreen>

<P>
The third element tells us what to expect in the fourth element.  There are 4 possibilities ....

<tscreen><verb>
     n - numeric list of numbers e.g. [ 1,2,3 ]
     r - ranges of pairs of numbers e.g. between 2 and 4 or 10 to 17 - [ 2,4, 10,17 ] 
     a - an alphanumeric regex
     d - the default rule
</verb></tscreen>

<P>
The fifth element is simply the hops to set in this filter.  This would only be used if the filter was for a node of course and overrides the hop count in hop_table.pl.

<P>
So, let's look at an example spot filter.  It does not matter in the example who the filter is to be used for.
So, what do we need in the filter?  We need to filter the spots the user/node requires and also set a default rule for anything else outside the filter.  Below is a simple filter that stops spots arriving from outside Europe.

<tscreen><verb>$in = [
  [ 0, 4, 'a', '^(K|N|A|W|VE|VA|J)'],  # 0 = drop, 'a' = alphanumeric
  [ 1, 0, 'd', 0, 1 ],                 # 1 = want, 'd' = everything else
		     ];
</verb></tscreen>

<P>
So the filter is wrapped in between a pair of square brackets.  This tells Spider to look in between these limits.  Then each line is contained within its own square brackets and ends with a comma.
Lets look carefully at the first line.  The first element is 0 (drop).  Therefore anything we put on this line will not be accepted.  The next element is 4.  This means we are filtering by the spotter.  The third element is the letter "a" which tells the program to expect an alphanumeric expression in the fourth element.  The fourth element is a list of letters separated by the pipe symbol.

<P>
What this line does is tell the program to drop any spots posted by anyone in the USA, Canada or Japan.

<P>
The second line is the default rule for anything else.  The "d" tells us this and the line simply reads... accept anything else.

<P>
You can add as many lines as you need to complete the filter but if there are several lines of the same type it is neater to enclose them all as one line.  An example of this is where specific bands are set.  We could write this like this ....

<tscreen><verb>
[ 0,0,'r',[1800.0, 2000.0], 1],
[ 0,0,'r',[10100.0, 10150.0], 1],
[ 0,0,'r',[14000.0, 14350.0], 1],
[ 0,0,'r',[18000.0, 18200.0], 1],
</verb></tscreen>

<P>
But the line below achieves the same thing and is more efficient ....

<tscreen><verb>
  [ 0, 0, 'r',
    [  
      1800.0, 2000.0,         # top band 
      10100.0, 10150.0,       # WARC  
      14000.0, 14350.0,       # 20m
      18000.0, 18200.0,       # WARC
    [ ,1 ],
</verb></tscreen>


<sect1>Announcements

<P>
<tscreen><verb>

# This is an example announce or filter allowing only West EU announces
# 
# The element list is:-
# 0 - callsign of announcer
# 1 - destination * = all, <callsign> = routed to the node
# 2 - text
# 3 - * - sysop, <some text> - special list eg 6MUK, ' ', normal announce
# 4 - origin
# 5 - 0 - announce, 1 - wx
# 6 - channel callsign (the interface from which this spot came)

$in = [
        [ 1, 0, 'a', '^(P[ABCDE]|DK0WCY|G|M|2|EI|F|ON)' ],
        [ 0, 0, 'd', 0 ]
];
</verb></tscreen>

In this example, only the prefixes listed will be allowed.  It is possible to be quite specific.  The Dutch prefix "P" is followed by several secondary identifiers which are allowed.  So, in the example, "PA" or "PE" would be ok but not "PG".  It is even possible to allow information from a single callsign.  In the example this is DK0WCY, to allow the posting of his Aurora Beacon.

<sect1>WWV

<P>
<tscreen><verb>

# This is an example WWV filter
# 
# The element list is:-
# 0 - nominal unix date of spot (ie the day + hour:13)
# 1 - the hour
# 2 - SFI
# 3 - K
# 4 - I
# 5 - text
# 6 - spotter
# 7 - origin
# 8 - incoming interface callsign

# this one doesn't filter, it just sets the hop count to 6 and is
# used mainly just to override any isolation from WWV coming from
# the internet.

$in = [
        [ 1, 0, 'd', 0, 6 ]
];

</verb></tscreen>

<P>
It should be noted that the filter will start to be used only once a user/node has logged out and back in again.
<P>
I am not going to spend any more time on these filters now as they will become more "comprehensive" in the near future.

<sect1>Filtering Mail

<P>
In the /spider/msg directory you will find a file called badmsg.pl.issue.  Rename this to badmsg.pl and edit the file.  The original looks something like this ....

<tscreen><verb>

# the list of regexes for messages that we won't store having
# received them (bear in mind that we must receive them fully before
# we can bin them)


# The format of each line is as follows

#     type      source             pattern 
#     P/B/F     T/F/O/S            regex  

# type: P - private, B - bulletin (msg), F - file (ak1a bull)
# source: T - to field, F - from field,  O - origin, S - subject 
# pattern: a perl regex on the field requested

# Currently only type B and P msgs are affected by this code.
# 
# The list is read from the top down, the first pattern that matches
# causes the action to be taken.

# The pattern can be undef or 0 in which case it will always be selected
# for the action specified



package DXMsg;

@badmsg = (
'B',    'T',    'SALE', 
'B',    'T',    'WANTED',
'B',    'S',    'WANTED',
'B',    'S',    'SALE', 
'B',    'S',    'WTB',
'B',    'S',    'WTS',
'B',    'T',    'FS',
);
</verb></tscreen>

<P>
I think this is fairly self explanatory.  It is simply a list of subject headers that we do not want to pass on to either the users of the cluster or the other cluster nodes that we are linked to.  This is usually because of rules and regulations pertaining to items for sale etc in a particular country.

<sect1>Filtering DX callouts

<P>
In the same way as mail, there are some types of spot we do not wish to pass on to users or linked cluster nodes.  In the /spider/data directory you will find a file called baddx.pl.issue.  Rename this to baddx.pl and edit the file.  The original looks like this ....

<tscreen><verb>

# the list of dx spot addresses that we don't store and don't pass on


package DXProt;

@baddx = qw 

 FROG 
 SALE
 FORSALE
 WANTED
 P1RATE
 PIRATE
 TEST
 DXTEST
 NIL
 NOCALL 
);
</verb></tscreen>

<P>
Again, this is simply a list of names we do not want to see in the spotted field of a DX callout.


<sect>Information, files and useful programs

<sect1>MOTD

<P>
One of the more important things a cluster sysop needs to do is to get information to his users.  The simplest way to do this is to have a banner that is sent to the user on login.  This is know as a "message of the day" or "motd".  To set this up, simply create a file in /spider/data called motd and edit it to say whatever you want.  It is purely a text file and will be sent automatically to anyone logging in to the cluster.

<sect1>Downtime message

<P>
If for any reason the cluster is down, maybe for upgrade or maintenance but the machine is still running, a message can be sent to the user advising them of the fact.  This message lives in the /spider/data directory and is called "offline".  Simply create the file and edit it to say whatever you wish.  This file will be sent to a user attempting to log into the cluster when DXSpider is not actually running.

<sect1>Other text messages

<P>
You can set other text messages to be read by the user if they input the file name.  This could be for news items or maybe information for new users.  To set this up, make a directory under /spider called <em>packclus</em>.  Under this directory you can create files called <em>news</em> or <em>newuser</em> for example.  In fact you can create files with any names you like.  These can be listed by the user with the command ....

<tscreen><verb>
show/files
</verb></tscreen>

They can be read by the user by typing the command ....

<tscreen><verb>
type news
</verb></tscreen>

If the file they want to read is called <em>news</em>.  You could also set an alias for this in the Alias file to allow them just to type <em>news</em>

<P>
You can also store other information in this directory, either directly or nested under directories.  One use for this would be to store DX bulletins such as the OPDX bulletins.  These can be listed and read by the user.  To keep things tidy, make a directory under /spider/packclus called <em>bulletins</em>.  Now copy any OPDX or similar bulletins into it.  These can be listed by the user in the same way as above using the <em>show/files</em> command with an extension for the bulletins directory you have just created, like this ....

<tscreen><verb>
show/files bulletins
</verb></tscreen>

<P>
An example would look like this ....

<tscreen><verb>
sh/files
bulletins      DIR 20-Dec-1999 1715Z news          1602 14-Dec-1999 1330Z
</verb></tscreen>

You can see that in the files area (basically the packclus directory) there is a file called <em>news</em> and a directory called <em>bulletins</em>.  You can also see that dates they were created.  In the case of the file <em>news</em>, you can also see the time it was last modified, a good clue as to whether the file has been updated since you last read it.  To read the file called <em>news</em> you would simply issue the command ....

<tscreen><verb>
type news
</verb></tscreen>

To look what is in the bulletins directory you issue the command ....

<tscreen><verb>
show/files bulletins
opdx390      21381 29-Nov-1999 1621Z opdx390.1     1670 29-Nov-1999 1621Z
opdx390.2     2193 29-Nov-1999 1621Z opdx391      25045 29-Nov-1999 1621Z  
opdx392      35969 29-Nov-1999 1621Z opdx393      15023 29-Nov-1999 1621Z  
opdx394      33429 29-Nov-1999 1621Z opdx394.1     3116 29-Nov-1999 1621Z  
opdx395      24319 29-Nov-1999 1621Z opdx396      32647 29-Nov-1999 1621Z
opdx396.1     5537 29-Nov-1999 1621Z opdx396.2     6242 29-Nov-1999 1621Z
opdx397      18433 29-Nov-1999 1621Z opdx398      19961 29-Nov-1999 1621Z  
opdx399      17719 29-Nov-1999 1621Z opdx400      19600 29-Nov-1999 1621Z
opdx401      27738 29-Nov-1999 1621Z opdx402      18698 29-Nov-1999 1621Z
opdx403      24994 29-Nov-1999 1621Z opdx404      15685 29-Nov-1999 1621Z
opdx405      13984 29-Nov-1999 1621Z opdx405.1     4166 29-Nov-1999 1621Z
opdx406      28934 29-Nov-1999 1621Z opdx407      24153 29-Nov-1999 1621Z
opdx408      15081 29-Nov-1999 1621Z opdx409      23234 29-Nov-1999 1621Z
Press Enter to continue, A to abort (16 lines) >
</verb></tscreen>

You can now read any file in this directory using the type command, like this ....

<tscreen><verb>
type bulletins/opdx391
Ohio/Penn DX Bulletin No. 391
The Ohio/Penn Dx PacketCluster
DX Bulletin No. 391
BID: $OPDX.391
January 11, 1999
Editor Tedd Mirgliotta, KB8NW
Provided by BARF-80 BBS Cleveland, Ohio
Online at 440-237-8208 28.8k-1200 Baud 8/N/1 (New Area Code!)
Thanks to the Northern Ohio Amateur Radio Society, Northern Ohio DX
Association, Ohio/Penn PacketCluster Network, K1XN & Golist, WB2RAJ/WB2YQH
& The 59(9) DXReport, W3UR & The Daily DX, K3TEJ, KN4UG, W4DC, NC6J, N6HR,
Press Enter to continue, A to abort (508 lines) >
</verb></tscreen>

The page length will of course depend on what you have it set to!

<sect1>The Aliases file

<P>
You will find a file in /spider/cmd/ called Aliases.  First, copy this file to /spider/local_cmd/Aliases and edit this file.  You will see something like this ...

<tscreen><verb>

#!/usr/bin/perl

# provide some standard aliases for commands for terminally
# helpless ak1a user (helpless in the sense that they never
# read nor understand help files)

# This file is automagically reloaded if its modification time is 
# later than the one stored in CmdAlias.pm

# PLEASE make this file consistant with reality! (the patterns MUST
# match the filenames!)

# Don't alter this file, copy it into the local_cmd tree and modify it.
# This file will be replaced everytime I issue a new release.

# You only need to put aliases in here for commands that don't work as
# you desire naturally, e.g sh/dx on its own just works as you expect
# so you need not add it as an alias.



package CmdAlias;

%alias = (
    '?' => [
          '^\?', 'apropos', 'apropos',
        ],
    'a' => [
          '^ann.*/full', 'announce full', 'announce', 
          '^ann.*/sysop', 'announce sysop', 'announce',
          '^ann.*/(.*)$', 'announce $1', 'announce',
        ],
        'b' => [
        ],
        'c' => [
        ],
        'd' => [
          '^del', 'kill', 'kill',
          '^del\w*/fu', 'kill full', 'kill',
          '^di\w*/a\w*', 'directory all', 'directory',
          '^di\w*/b\w*', 'directory bulletins', 'directory',
          '^di\w*/n\w*', 'directory new', 'directory',
          '^di\w*/o\w*', 'directory own', 'directory',
          '^di\w*/s\w*', 'directory subject', 'directory',
          '^di\w*/t\w*', 'directory to', 'directory',
          '^di\w*/f\w*', 'directory from', 'directory',
          '^di\w*/(\d+)', 'directory $1', 'directory',
        ],
        'e' => [
        ],
        'f' => [
        ],
        'g' => [
        ],
        'h' => [
        ],
        'i' => [
        ],
        'j' => [
        ],
        'k' => [
        ],
        'l' => [
          '^l$', 'directory', 'directory',
          '^ll$', 'directory', 'directory',
          '^ll/(\d+)', 'directory $1', 'directory',
        ],
        'm' => [
        ],
        'n' => [
          '^news', 'type news', 'type',
        ],
        'o' => [
        ],
        'p' => [
        ],
        'q' => [
          '^q', 'bye', 'bye',
        ],
        'r' => [        
          '^r$', 'read', 'read',
          '^rcmd/(\S+)', 'rcmd $1', 'rcmd',
        ],
        's' => [
          '^s/p$', 'send', 'send',
          '^sb$', 'send noprivate', 'send',
          '^set/home$', 'set/homenode', 'set/homenode',
          '^set/nobe', 'unset/beep', 'unset/beep',
          '^set/nohe', 'unset/here', 'unset/here',
          '^set/noan', 'unset/announce', 'unset/announce',
          '^set/nodx', 'unset/dx', 'unset/dx',
          '^set/nota', 'unset/talk', 'unset/talk',
          '^set/noww', 'unset/wwv', 'unset/wwv',
          '^set/nowx', 'unset/wx', 'unset/wx',
          '^sh$', 'show', 'show',
          '^sh\w*/buck', 'dbshow buck', 'dbshow',
          '^sh\w*/bu', 'show/files bulletins', 'show/files',
          '^sh\w*/c/n', 'show/configuration nodes', 'show/configuration',
          '^sh\w*/c$', 'show/configuration', 'show/configuration',
          '^sh\w*/com', 'dbavail', 'dbavail',
          '^sh\w*/dx/(\d+)-(\d+)', 'show/dx $1-$2', 'show/dx',
          '^sh\w*/dx/(\d+)', 'show/dx $1', 'show/dx',
          '^sh\w*/dx/d(\d+)', 'show/dx from $1', 'show/dx',
          '^sh\w*/email', 'dbshow email', 'dbshow',
          '^sh\w*/hftest', 'dbshow hftest', 'dbshow',
          '^sh\w*/vhftest', 'dbshow vhftest', 'dbshow',
          '^sh\w*/qsl', 'dbshow qsl', 'dbshow',
          '^sh\w*/tnc', 'who', 'who',
      '^sh\w*/up', 'show/cluster', 'show/cluster',
          '^sh\w*/w\w*/(\d+)-(\d+)', 'show/wwv $1-$2', 'show/wwv',
          '^sh\w*/w\w*/(\d+)', 'show/wwv $1', 'show/wwv',
          '^sp$', 'send', 'send',
        
    ],
        't' => [
          '^ta$', 'talk', 'talk',
          '^t$', 'talk', 'talk',
        ],
        'u' => [
        ],
        'v' => [
        ],
        'w' => [
          '^wx/full', 'wx full', 'wx',
          '^wx/sysop', 'wx sysop', 'wx',
        ],
        'x' => [
        ],
        'y' => [
        ],
        'z' => [
        ],
)
</verb></tscreen>

You can create aliases for commands at will.  Beware though, these may not always turn out as you think.  Care is needed and you need to test the results once you have set an alias.

<sect1>Forward.pl

<P>
DXSpider receives all and any mail sent to it without any alterations needed
in files.  Because personal and bulletin mail are treated differently, there
is no need for a list of accepted bulletin addresses.  It is necessary, however,
to tell the program which links accept which bulletins.  For example, it is
pointless sending bulletins addresses to "UK" to any links other than UK
ones.  The file that does this is called forward.pl and lives in /spider/msg.
At default, like other spider files it is named forward.pl.issue.  Rename it
to forward.pl and edit the file to match your requirements.
The format is below ...

<tscreen><verb>
#
# this is an example message forwarding file for the system
#
# The format of each line is as follows
#
#     type    to/from/at pattern action  destinations
#     P/B/F     T/F/A     regex   I/F    [ call [, call ...] ]
#
# type: P - private, B - bulletin (msg), F - file (ak1a bull)
# to/from/at: T - to field, F - from field, A - home bbs, O - origin 
# pattern: a perl regex on the field requested
# action: I - ignore, F - forward
# destinations: a reference to an array containing node callsigns
#
# if it is non-private and isn't in here then it won't get forwarded 
#
# Currently only type B msgs are affected by this code.
# 
# The list is read from the top down, the first pattern that matches
# causes the action to be taken.
#
# The pattern can be undef or 0 in which case it will always be selected
# for the action specified
#
# If the BBS list is undef or 0 and the action is 'F' (and it matches the
# pattern) then it will always be forwarded to every node that doesn't have 
# it (I strongly recommend you don't use this unless you REALLY mean it, if
# you allow a new link with this on EVERY bull will be forwarded immediately
# on first connection)
#

package DXMsg;

@forward = (
'B',    'T',    'LOCAL',        'F',    [ qw(GB7MBC) ],
'B',    'T',    'ALL',          'F',    [ qw(GB7BAA GB7ADX PA4AB-14) ],
'B',    'T',    'UK',           'F',    [ qw(GB7BAA GB7ADX) ],
'B',    'T',    'QSL',          'F',    [ qw(GB7BAA GB7ADX PA4AB-14) ],
'B',    'T',    'QSLINF',       'F',    [ qw(GB7BAA GB7ADX PA4AB-14) ],
'B',    'T',    'DX',           'F',    [ qw(GB7BAA GB7ADX PA4AB-14) ],
'B',    'T',    'DXINFO',       'F',    [ qw(GB7BAA GB7ADX PA4AB-14) ],
'B',    'T',    'DXNEWS',       'F',    [ qw(GB7BAA GB7ADX PA4AB-14) ],
'B',    'T',    'DXQSL',        'F',    [ qw(GB7BAA GB7ADX PA4AB-14) ],
'B',    'T',    'SYSOP',        'F',    [ qw(GB7BAA GB7ADX) ],
'B',    'T',    '50MHZ',        'F',    [ qw(GB7BAA GB7ADX PA4AB-14) ],
);
</verb></tscreen>

Simply insert a bulletin address and state in the brackets where you wish
that mail to go.  For example, you can see here that mail sent to "UK" will
only be sent to the UK links and not to PA4AB-14.

<P>
To force the cluster to reread the file use load/forward

<sect1>Distribution lists

<P>
Distribution lists are simply a list of users to send certain types of
mail to.  An example of this is mail you only wish to send to other
sysops.  In /spider/msg there is a directory called <em>distro</em>.  You
put any distibution lists in here.  For example, here is a file called
SYSOP.pl that caters for the UK sysops.

<tscreen><verb>
qw(GB7TLH GB7DJK GB7DXM GB7CDX GB7BPQ GB7DXN GB7MBC GB7MBC-6 GB7MDX
   GB7NDX GB7SDX GB7TDX GB7UDX GB7YDX GB7ADX GB7BAA GB7DXA GB7DXH 
   GB7DXK GB7DXI GB7DXS)
</verb></tscreen>

Any mail sent to "sysop" would only be sent to the callsigns in this list.
 
<sect1>Console.pl

<P>
In later versions of Spider a simple console program is provided for the sysop.  This has a type ahead buffer with line editing facilities and colour for spots, announces etc.
To use this program, simply use console.pl instead of client.pl.

<P>
To edit the colours, copy /spider/perl/Console.pl to /spider/local and edit the file with your favourite editor.

<sect>Sysop commands

<P>
Most maintenance tasks are automatic but there are some commands that are useful for a sysop.  These are listed below in alphabetical order.  The number in brackets following the command name is the permissions level needed to use the command.

<sect1>announce sysop (5)

<P>
<tt>
<bf>announce sysop &lt;text&gt;</bf>
</tt>

<P>
Send an announcement to Sysops only

<sect1>connect (5) 

<P>
<tt>
<bf>connect &lt;callsign&gt;</bf> Start a connection to another DX Cluster
</tt>

<P>
Start a connection process that will culminate in a new connection to the
DX cluster &lt;callsign&gt;. This process creates a new 'client' process which will
use the script in /spider/connect/&lt;callsign&gt; to effect the 'chat' exchange
necessary to traverse the network(s) to logon to the cluster &lt;callsign&gt;.


<sect1>catch (9) 

<P>
<tt>
<bf>&lt;node_call&gt; All [&lt;msgno&gt; ...]</bf> Mark a message as sent
</tt>

<P>
When you send messages the fact that you have forwarded it to another node 
is remembered so that it isn't sent again. When you have a new partner
node and you add their callsign to your /spider/msg/forward.pl file, all
outstanding non-private messages will be forwarded to them. This may well
be ALL the non-private messages. You can prevent this by using these 
commmands:-

  catch GB7DJK all
  catch GB7DJK 300 301 302 303
        
and to undo what you have just done:-
  
  uncatch GB7DJK all
  uncatch GB7DJK 300 301 302 303

which will arrange for them to be forward candidates again.

<sect1>dbcreate (9)

<P>
<tt>
<bf>dbcreate &lt;name&gt;</bf> Create a database entry<newline>
<bf>dbcreate &lt;name&gt; chain &lt;name&gt; [&lt;name&gt;..]</bf> Create a chained database entry<newline>
<bf>dbcreate &lt;name&gt; remote &lt;node&gt;</bf> Create a remote database entry<newline>
</tt>

<P>
DBCREATE allows you to define a database in the system. It doesn't actually
create anything, just defines it.

The databases that are created are simple DB_File hash databases, they are 
therefore already 'indexed'.

You can define a local database with the first form of the command eg:

  DBCREATE oblast

You can also chain databases with the addition of the 'chain' keyword. 
This will search each database one after the other. A typical example 
is:

  DBCREATE sdx_qsl chain sql_ad

No checking is done to see if the any of the chained databases exist, in
fact it is usually better to do the above statement first then do each of
the chained databases.

Databases can exist offsite. To define a database that lives on another 
node do:

  DBCREATE buckmaster remote gb7dxc

Remote databases cannot be chained; however, the last database in a 
a chain can be a remote database eg:

  DBCREATE qsl chain gb7dxc

To see what databases have been defined do:

  DBAVAIL (or it will have been aliased to SHOW/COMMAND)

It would be normal for you to add an entry into your local Aliases file
to allow people to use the 'SHOW/&lt;dbname&gt;' style syntax. So you would
need to add a line like:-

<tscreen><verb>
  's' => [
    ..
    ..
    '^sh\w*/buc', 'dbshow buckmaster', 'dbshow',
    ..
    ..
   ],
</verb></tscreen>

to allow 

  SH/BUCK g1tlh

to work as they may be used to.

See DBIMPORT for the importing of existing AK1A format data to databases.
See DBSHOW for generic database enquiry

<sect1>dbimport (9)

<P>
<tt>
<bf>dbimport &lt;dbname&gt;</bf> Import AK1A data into a database
</tt>

<P>
If you want to import or update data in bulk to a database you can use
this command. It will either create or update entries into an existing
database. For example:-

  DBIMPORT oblast /tmp/OBLAST.FUL

will import the standard OBLAST database that comes with AK1A into the
oblast database held locally.

<sect1>dbremove (9)

<P>
<tt>
<bf>dbremove &lt;dbname&gt;</bf> Delete a database
</tt>

<P>
DBREMOVE will completely remove a database entry and also delete any data
file that is associated with it. 

There is no warning, no comeback, no safety net. 

For example:

  DBREMOVE oblast 

will remove the oblast database from the system and it will also remove
the associated datafile.

I repeat:

There is no warning, no comeback, no safety net.

You have been warned.

<sect1>debug (9)

<P>
<tt>
<bf>debug</bf> Set the cluster program into debug mode
</tt>

<P>
Executing this command will only have an effect if you are running the cluster
in debug mode i.e.

<tscreen><verb>
        perl -d cluster.pl
</verb></tscreen>

It will interrupt the cluster just after the debug command has finished.

<sect1>directory (5)

<P>
Works just like the user command except that sysops can see ALL messages.

<sect1>disconnect (8)

<P>
<tt>
<bf>disconnect &lt;call&gt; [&lt;call&gt; ...]</bf> Disconnect a user or node
</tt>

<P>
Disconnect any &lt;call&gt; connected locally

<sect1>export (9)

<P>
<tt>
<bf>export &lt;msgno&gt; &lt;filename&gt;</bf> Export a message to a file
</tt>

<P>
Export a message to a file. This command can only be executed on a local
console with a fully privileged user. The file produced will be in a form
ready to be imported back into the cluster by placing it in the import 
directory (/spider/msg/import).

This command cannot overwrite an existing file. This is to provide some 
measure of security. Any files written will owned by the same user as the 
main cluster, otherwise you can put the new files anywhere the cluster can
access. For example:-

  EXPORT 2345 /tmp/a

<sect1>forward/opername (1)

<P>
<tt>
<bf>forward/opername &lt;call&gt;</bf> Send out information on this &lt;call&gt; to all clusters
</tt>

<P>
This command sends out any information held in the user file which can 
be broadcast in PC41 protocol packets. This information is Name, QTH, Location
and Homenode. PC41s are only sent for the information that is available.

<sect1>init (5)

<P>
<tt>
<bf>init &lt;node call&gt;</bf> Re-initialise a link to an AK1A compatible node
</tt>

<P>
This command attempts to re-initialise a link to a (usually) AK1A node
that has got confused, usually by a protocol loop of some kind. It may
work - but you usually will be better off simply disconnecting it (or
better, if it is a real AK1A node, doing an RCMD &lt;node&gt; DISC/F &lt;your
node&gt;).

Best of luck - you will need it.

<sect1>kill (5)

<P>
<tt>
<bf>kill &lt;msgno&gt [&lt;msgno&gt; ...]</bf> Remove or erase a message from the system<newline>
<bf>kill from &lt;call&gt;</bf> Remove all messages from a callsign<newline>
<bf>kill to &lt;call&gt;</bf> Remove all messages to a callsign<newline>
</tt>

<P>
You can get rid of any message to or originating from your callsign using 
this command. You can remove more than one message at a time.

As a sysop you can kill any message on the system.

<sect1>kill full (5)

<tt>
<bf>kill full &lt;msgno&gt; [&lt;msgno&gt;]</bf> Delete a message from the whole cluster
</tt>

<P>
Delete a message (usually a 'bulletin') from the whole cluster system. 

This uses the subject field, so any messages that have exactly the same subject
will be deleted. Beware!

<sect1>load/aliases (9)

<P>
<tt>
<bf>load/aliases</bf> Reload the command alias table
</tt>

<P>
Reload the /spider/cmd/Aliases file after you have editted it. You will need to
do this if you change this file whilst the cluster is running in order for the
changes to take effect.

<sect1>load/bands (9)

<P>
<tt>
<bf>load/bands</bf> Reload the band limits table
</tt>

<P>
Reload the /spider/data/bands.pl file if you have changed it manually whilst
the cluster is running. 

<sect1>load/cmd_cache (9)

<P>
<tt>
<bf>load/cmd_cache</bf> Reload the automatic command cache
</tt>

<P>
Normally, if you change a command file in the cmd or local_cmd tree it will
automatially be picked up by the cluster program. Sometimes it can get confused
if you are doing a lot of moving commands about or delete a command in the 
local_cmd tree and want to use the normal one again. Execute this command to
reset everything back to the state it was just after a cluster restart.

<sect1>load/messages (9)

<P>
<tt>
<bf>load/messages</bf> Reload the system messages file
</tt>

<P>
If you change the /spider/perl/Messages file (usually whilst fiddling/writing ne
commands) you can have them take effect during a cluster session by executing this
command. You need to do this if get something like :-

unknown message 'xxxx' in lang 'en'

<sect1>load/prefixes (9)

<P>
<tt>
<bf>load/prefixes</bf> Reload the prefix table
</tt>

<P>
Reload the /spider/data/prefix_data.pl file if you have changed it manually whilst
the cluster is running. 

<sect1>merge (5)

<P>
<tt>
<bf>merge &lt;node&gt; [&lt;no spots&gt;/&lt;no wwv&gt;]</bf> Ask for the latest spots and WWV
</tt>

<P>
MERGE allows you to bring your spot and wwv database up to date. By default
it will request the last 10 spots and 5 WWVs from the node you select. The 
node must be connected locally.

You can request any number of spots or wwv and although they will be appended
to your databases they will not duplicate any that have recently been added 
(the last 2 days for spots and last month for WWV data).

<sect1>msg (9)

<P>
<tt>
<bf>msg &lt;cmd&gt; &lt;msgno&gt; [data ...]</bf> Alter various message parameters
</tt>

<P>
Alter message parameters like To, From, Subject, whether private or bulletin
or return receipt (RR) is required or whether to keep this message from timing
out.

<tscreen><verb>
  MSG TO <msgno> <call>     - change TO callsign to <call>
  MSG FRom <msgno> <call>   - change FROM callsign to <call>
  MSG PRrivate <msgno>      - set private flag
  MSG NOPRrivate <msgno>    - unset private flag
  MSG RR <msgno>            - set RR flag
  MSG NORR <msgno>          - unset RR flag
  MSG KEep <msgno>          - set the keep flag (message won't be deleted ever)
  MSG NOKEep <msgno>        - unset the keep flag
  MSG SUbject <msgno> <new> - change the subject to <new>
  MSG WAittime <msgno>      - remove any waitting time for this message
  MSG NOREad <msgno>        - mark message as unread
  MSG REad <msgno>          - mark message as read
  MSG QUeue                 - queue any outstanding bulletins
  MSG QUeue 1               - queue any outstanding private messages
</verb></tscreen>

You can look at the status of a message by using:-

  STAT/MSG &lt;msgno&gt;      

This will display more information on the message than DIR does.

<sect1>pc (8)

<P>
<tt>
<bf>pc &lt;call&gt; &lt;text&gt;</bf> Send text (eg PC Protocol) to &lt;call&gt;
</tt>

<P>
Send some arbitrary text to a locally connected callsign. No processing is done on
the text. This command allows you to send PC Protocol to unstick things if problems
arise (messages get stuck etc). eg:-

   pc gb7djk PC33^GB7TLH^GB7DJK^400^

You can also use in the same way as a talk command to a connected user but
without any processing, added of "from &lt;blah&gt; to &lt;blah&gt;" or whatever.

   pc G1TLH Try doing that properly!!!

<sect1>ping (1)

<P>
<tt>
<bf>ping &lt;node&gt;</bf> Send a ping command to another cluster node
</tt>

<P>
This command is used to estimate the quality of the link to another cluster. 
The time returned is the length of time taken for a PC51 to go to another 
cluster and be returned.

Any visible cluster node can be PINGed.

<sect1>rcmd (1)

<P>
<tt>
<bf>rcmd &lt;node call&gt; &lt;cmd&gt;</bf> Send a command to another DX cluster
</tt>

<P>
This command allows you to send nearly any command to another DX Cluster
node that is connected to the system. 

Whether you get any output is dependant on a) whether the other system knows
that the node callsign of this cluster is in fact a node b) whether the
other system is allowing RCMDs from this node and c) whether you have
permission to send this command at all.

<sect1>read (5)

<P>
<tt>
<bf>read &lt;msgno&gt;</bf> Read a message on the system
</tt>

<P>
As a sysop you may read any message on the system

<sect1>set/debug (9)

<P>
<tt>
<bf>set/debug &lt;name&gt;</bf> Add a debug level to the debug set
</tt>

<P>
You can remove this level with unset/debug &lt;name&gt;

<sect1>set/isolate (9)

<P>
<tt>
<bf>set/isolate &lt;node call&gt;</bf> Isolate a node from the rest of the network
</tt>

<P>
Connect a node to your system in such a way that you are a full protocol
member of its network and can see all spots on it, but nothing either leaks
out from it nor goes back into from the rest of the nodes connected to you.

You can potentially connect several nodes in this way.

You can see which nodes are isolated with the show/isolate (1) command.

You can remove the isolation with the command unset/isolate.

<sect1>set/sys_location (9)

<P>
<tt>
<bf>set/sys_location &lt;lat & long&gt;</bf> Set your cluster latitude and longitude
</tt>

<P>
In order to get accurate headings and such like you must tell the system
what your latitude and longitude is. If you have not yet done a SET/QRA
then this command will set your QRA locator for you. For example:-

  SET/LOCATION 52 22 N 0 57 E

<sect1>set/lockout (9)

<P>
<tt>
<bf>set/lockout &lt;call&gt;</bf> Stop a callsign connecting to the cluster
</tt>

<P>
You can show who is locked out with the show/lockout (9) command.

To allow the user to connect again, use the command unset/lockout

<sect1>set/node (9)

<P>
<tt>
<bf>set/node &lt;call&gt; [&lt;call&gt; ...]</bf> Make the callsign an AK1A cluster
</tt>

<P>
Tell the system that the call(s) are to be treated as AK1A cluster and
fed PC Protocol rather normal user commands.

From version 1.41 you can also set the following types of cluster

<verb>
set/spider
set/dxnet
set/clx
set/arcluster
</verb>

To see what your nodes are set to, use the show/nodes command.

<sect1>set/obscount (9)

<P>
<tt>
<bf>set/obscount &lt;count&gt; &lt;node call&gt;</bf> Set the 'pump-up' obscelence counter
</tt>

<P>
From version 1.35 onwards neighbouring nodes are pinged at regular intervals (see
SET/PINGINTERVAL), usually 300 seconds or 5 minutes. There is a 'pump-up'
counter which is decremented on every outgoing ping and then reset to
the 'obscount' value on every incoming ping. The default value of this
parameter is 2. 

What this means is that a neighbouring node will be pinged twice at 
(default) 300 second intervals and if no reply has been heard just before
what would be the third attempt, that node is disconnected.

If a ping is heard then the obscount is reset to the full value. Using
default values, if a node has not responded to a ping within 15 minutes,
it is disconnected.

<sect1>set/pinginterval (9)

<P>
<tt>
<bf>set/pinginterval &lt;time&gt; &lt;node call&gt;</bf> Set the ping time to neighbouring nodes
</tt>

<P>
As from version 1.35 all neighbouring nodes are pinged at regular intervals
in order to determine the rolling quality of the link and, in future, to
affect routing decisions. The default interval is 300 secs or 5 minutes.

You can use this command to set a different interval. Please don't. 

But if you do the value you enter is treated as minutes up 60 and seconds
for numbers greater than that.

This is used also to help determine when a link is down at the far end
(as certain cluster software doesn't always notice), see SET/OBSCOUNT
for more information.

<sect1>set/privilege (9)

<P>
<tt>
<bf>set/privilege &lt;n&gt; &lt;call&gt; [&lt;call&gt; ...]</bf> Set the privilege level on a call
</tt>

<P>
Set the privilege level on a callsign. The privilege levels that pertain
to commands are as default:-

<tscreen><verb>
  0 - normal user
  1 - allow remote nodes normal user RCMDs
  5 - various privileged commands (including shutdown, but not disc-
      connect), the normal level for another node.
  8 - more privileged commands (including disconnect)
  9 - local sysop privilege. DO NOT SET ANY REMOTE USER OR NODE TO THIS
      LEVEL.
</verb></tscreen>

If you are a sysop and you come in as a normal user on a remote connection
your privilege will automatically be set to 0.

<sect1>set/password (9)

<P>
<tt>
<bf>set/password &lt;callsign&gt; &lt;string&gt;</bf> Set a users password
</tt>

<P>
The password for a user can only be set by a full sysop. The string
can contain any characters but any spaces are removed (you can type in
spaces - but they won't appear in the password). You can see the
result with STAT/USER.  The password is the usual 30 character baycom
type password.

<sect1>set/sys_qra (9)

<P>
<tt>
<bf>set/sys_qra &lt;locator&gt;</bf> Set your cluster QRA locator
</tt>

<sect1>show program (5)

<P>
<tt>
<bf>show/program</bf> Show the locations of all the included program modules
</tt>

<P>
Show the name and location where every program module was load from. This
is useful for checking where you think you have loaded a .pm file from.

<sect1>shutdown (5)

<P>
<tt>
<bf>shutdown</bf> Shutdown the cluster
</tt>

<P>
Shutdown the cluster and disconnect all the users.  If you have Spider
set to respawn in /etc/inittab it will of course restart.

<sect1>spoof (9)

<P>
<tt>
<bf>spoof &lt;callsign&gt; &lt;command&gt;</bf> Run commands as another user
</tt>

<P>
This is a very simple yet powerful command for the sysop.  It allows you to
issue commands as if you were a different user.  This is very useful for the
kind of things that users seem to always get wrong.. like home_node for
example.

<sect1>stat/db (5)

<P>
<tt>
<bf>stat/db &lt;dbname&gt;</bf> Show the status of a database
</tt>

<P>
Show the internal status of a database descriptor.

Depending on your privilege level you will see more or less information. 
This command is unlikely to be of much use to anyone other than a sysop.

<sect1>stat/channel (5)

<P>
<tt>
<bf>stat/channel &lt;callsign&gt;</bf> Show the status of a channel on the cluster
</tt>

<P>
Show the internal status of the channel object either for the channel that 
you are on or else for the callsign that you asked for.

Only the fields that are defined (in perl term) will be displayed.

<sect1>stat/msg (5)

<P>
<tt>
<bf>stat/msg &lt;msgno&gt;</bf> Show the status of a message
</tt>

<P>
This command shows the internal status of a message and includes information
such as to whom it has been forwarded, its size, origin etc etc.

<sect1>stat/user (5)

<P>
<tt>
<bf>stat/user &lt;callsign&gt;</bf> Show the full status of a user
</tt>

<P>
Shows the full contents of a user record including all the secret flags
and stuff.

Only the fields that are defined (in perl term) will be displayed.



</article>
